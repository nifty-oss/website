"use strict";(self.webpackChunknifty_docs=self.webpackChunknifty_docs||[]).push([[426],{1815:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var o=r(4848),n=r(8453);const a={slug:"proxy-pattern",title:"Extending program behaviour using a Proxy Pattern",authors:["febo"],tags:["solana","program","interface","extensions"]},i=void 0,s={permalink:"/blog/proxy-pattern",source:"@site/blog/2024-04-04proxy-pattern.md",title:"Extending program behaviour using a Proxy Pattern",description:"...and defining a program interface in the process.",date:"2024-04-04T00:00:00.000Z",formattedDate:"April 4, 2024",tags:[{label:"solana",permalink:"/blog/tags/solana"},{label:"program",permalink:"/blog/tags/program"},{label:"interface",permalink:"/blog/tags/interface"},{label:"extensions",permalink:"/blog/tags/extensions"}],readingTime:5.755,hasTruncateMarker:!1,authors:[{name:"febo",url:"https://github.com/febo",imageURL:"https://github.com/febo.png",key:"febo"}],frontMatter:{slug:"proxy-pattern",title:"Extending program behaviour using a Proxy Pattern",authors:["febo"],tags:["solana","program","interface","extensions"]},unlisted:!1},c={authorsImageUrls:[void 0]},d=[{value:"Introduction",id:"introduction",level:3},{value:"Enter a new pattern: Proxy",id:"enter-a-new-pattern-proxy",level:3},{value:"Putting it all together",id:"putting-it-all-together",level:3},{value:"Summary",id:"summary",level:3}];function l(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h3:"h3",li:"li",ol:"ol",p:"p",ul:"ul",...(0,n.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:(0,o.jsx)(t.em,{children:"...and defining a program interface in the process."})}),"\n",(0,o.jsx)(t.admonition,{title:"TL;DR",type:"tip",children:(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Nifty Asset program provides a program interface for developers to fully customise its behaviour."}),"\n",(0,o.jsx)(t.li,{children:'Follows a simpler and yet more powerful pattern than "hooks".'}),"\n",(0,o.jsx)(t.li,{children:"No changes are required on the program to support new behaviour."}),"\n",(0,o.jsx)(t.li,{children:"Client SDK makes using it nearly as trivial as using Nifty Asset directly."}),"\n"]})}),"\n",(0,o.jsx)(t.h3,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(t.p,{children:'The standard method for extending the behaviour of a program to execute custom logic on Solana involves using "hooks," which are program-defined callbacks. These callbacks allow a program to incorporate custom logic from a predetermined "hooked" program via Cross-Program Invocation (CPI). This method was first introduced by the Token Extensions program (also known as SPL Token-2022) and its Transfer Hook extension \u2013\xa0its purpose is to be able to execute custom logic every time a token from a particular mint is transferred,  including logic that could "block" the transfer of the token.'}),"\n",(0,o.jsx)("p",{align:"center",children:(0,o.jsxs)("figure",{children:[(0,o.jsx)("img",{src:r(4428).A,alt:"Hook Pattern",width:"500"}),(0,o.jsxs)("figcaption",{children:[(0,o.jsx)("b",{children:"The Hook pattern:"})," Program B is a ",(0,o.jsx)("i",{children:"hook"})," on Program A. Program A includes custom logic to invoke Program B."]})]})}),"\n",(0,o.jsx)(t.p,{children:'The Transfer Hook extension defines a common interface that programs must implement to receive transfer CPI callbacks when a token from a specific mint account is transferred. This callback is guaranteed to occur every time a mint with a transfer hook is transferred. Although this method enables various use cases, including deciding whether a transfer should succeed or not, it has an two important limitations: (1) the target program must embed the logic for hooks, and (2) the hooked program cannot write additional data to an account owned by the target program or perform any other instruction involving the target program. The second limitation arrises from the rule that prohibits program reentry \u2013 e.g., if Program A invokes Program B, Program B cannot invoke Program A. While it is possible that a program (Program B) returns data from a CPI call, deciding what to do with the data requires custom logic on the target program (Program A) and the types of actions to be performed will always be limited by the existing logic \u2013 new "actions" can only happen if the logic for them is added on Program A.'}),"\n",(0,o.jsx)(t.h3,{id:"enter-a-new-pattern-proxy",children:"Enter a new pattern: Proxy"}),"\n",(0,o.jsxs)(t.p,{children:['For those who are already familiar with design patterns for object-oriented programming, a "',(0,o.jsx)("i",{children:"Proxy provides a surrogate or placeholder for another object to control access to it"}),'". Replace "another object" by "another program", and now we have a pattern to gate access to a program. Going back to the initial example of the mint account, our aim is to have a Program B that defines custom behaviour any time Program A is called to transfer a token from a specific mint. In this case, Program B acts as a proxy to Program A. In other words, we flip the "hook" model upside-down and invert its order: Program B (the one that adds custom logic) receives the instruction, performs any custom logic and forwards the instruction to Program A (the one that actually performs the transfer).']}),"\n",(0,o.jsx)("p",{align:"center",children:(0,o.jsxs)("figure",{children:[(0,o.jsx)("img",{src:r(3827).A,alt:"Proxy Pattern",width:"500"}),(0,o.jsxs)("figcaption",{children:[(0,o.jsx)("b",{children:"The Hook pattern:"})," Program B is a hook on Program A. Program A includes custom logic to invoke Program B."]})]})}),"\n",(0,o.jsx)(t.p,{children:'This pattern offers two significant benefits. First, it removes the limitations on CPIs from Program B to Program A, allowing Program B to make CPI calls that write additional data to accounts controlled by Program A. Second, Program A is not required to incorporate any custom logic for "hooks" and it does not even need to be aware of any additional logic that was performed.'}),"\n",(0,o.jsx)(t.p,{children:'You might be wondering how to ensure that the proxy program (Program B) is always invoked when an account from Program A is being manipulated. The answer is Program Derived Addresses (PDAs) combined with a simple rule: when Program A is manipulating a "proxied" account \u2013\xa0an account that was created as a PDA from Program B \u2013 it always requires the account to be a signer. Since a PDA can only be signed by the program from which it was derived, this guarantees that the instruction must be going through the proxy program \u2013 the proxy program (Program B) adds the PDA signature for the account before forwarding the instruction to Program A.'}),"\n",(0,o.jsx)(t.p,{children:"For the Proxy pattern to work, the proxy program (Program B) supports the same instructions layout as the target program (Program A) and can add any custom logic when processing these instructions."}),"\n",(0,o.jsx)(t.p,{children:"We now have a generic pattern to create extensible programs and, in the process, we defined a way to specify program interfaces \u2013\xa0it is possible to compose programs together sharing the same interface to add additional behaviour."}),"\n",(0,o.jsx)(t.h3,{id:"putting-it-all-together",children:"Putting it all together"}),"\n",(0,o.jsx)(t.p,{children:"Nifty Asset is the first program implementing the Proxy pattern to allow developers extend its behaviour. This is achieved by:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:['Using a "Proxy" extension to identify accounts that are "proxied" \u2013 these accounts will be required to be a signer on instructions that manipulate them. The extension stores the information for clients to determine the address (',(0,o.jsx)(t.code,{children:"pubkey"}),") of the proxy program; it also includes the ",(0,o.jsx)(t.code,{children:"seeds"})," and ",(0,o.jsx)(t.code,{children:"bump"})," information for a proxy program to add a signature for the account."]}),"\n"]}),"\n",(0,o.jsx)("p",{align:"center",children:(0,o.jsx)("figure",{children:(0,o.jsx)("img",{src:r(9930).A,alt:"Proxy Extension",width:"300"})})}),"\n",(0,o.jsxs)(t.ol,{start:"2",children:["\n",(0,o.jsx)(t.li,{children:'Providing a program interface so proxy programs can parse Nifty Asset instructions. Proxy programs implement handlers for each of these instructions to add custom behaviour; the program can also decide that some instructions are not allowed and therefore cannot be executed. The main purpose of the proxy program is to sign the instruction on behalf of the asset account \u2013 the address of the asset account is a PDA of the proxy program, so it is the only program that can sign the instruction. Without its signature, the Nifty Asset program will not execute an instruction manipulating a "proxied" asset.'}),"\n"]}),"\n",(0,o.jsx)("p",{align:"center",children:(0,o.jsx)("figure",{children:(0,o.jsx)("img",{src:r(9302).A,alt:"Processor",width:"500"})})}),"\n",(0,o.jsxs)(t.ol,{start:"3",children:["\n",(0,o.jsx)(t.li,{children:'Extending the JavaScript SDK to support executing instructions using a proxy. This is as simple as executing instructions directly on Nifty Asset program. Every instruction builder has an optional "proxy" argument, which corresponds to the address of the proxy program to use when one is needed.'}),"\n"]}),"\n",(0,o.jsx)("p",{align:"center",children:(0,o.jsx)("figure",{children:(0,o.jsx)("img",{src:r(1009).A,alt:"SDK",width:"450"})})}),"\n",(0,o.jsxs)(t.p,{children:["The GitHub ",(0,o.jsx)(t.a,{href:"https://github.com/nifty-oss/asset",children:"\u2398repository"})," includes an example of a proxy program that tracks the number of times an asset has been transferred and changes the colour of its on-chain image on every transfer."]}),"\n",(0,o.jsx)(t.h3,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(t.p,{children:"The Proxy pattern provides a simple, non-intrusive, yet powerful way to extend the behaviour of a program. It allows adding custom behaviour without requiring modifications to the program and avoids limitations of CPI reentrancy and use of return data."}),"\n",(0,o.jsx)(t.p,{children:"Nifty Asset now provides a program interface for developers to build on top and fully customise its behaviour."})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},4428:(e,t,r)=>{r.d(t,{A:()=>o});const o=r.p+"assets/images/hook-pattern-f091740d20ed25da8a35c9c5ea4dfc12.jpg"},9302:(e,t,r)=>{r.d(t,{A:()=>o});const o=r.p+"assets/images/processor-89648cfdd9b5b9d14a2f58c6e1ffe8d4.png"},9930:(e,t,r)=>{r.d(t,{A:()=>o});const o=r.p+"assets/images/proxy-extension-1ffba0bbd77b5a796b9bb3e066be0ce9.png"},3827:(e,t,r)=>{r.d(t,{A:()=>o});const o=r.p+"assets/images/proxy-pattern-4162c32d85c196075610009305e98933.jpg"},1009:(e,t,r)=>{r.d(t,{A:()=>o});const o=r.p+"assets/images/sdk-proxy-2a5848ae81f49ef81fd584e112524d9d.png"},8453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>s});var o=r(6540);const n={},a=o.createContext(n);function i(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);